"""CLI entrypoint for Kindling design-time tooling."""

import os
import sys
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

import click
import yaml

from kindling_sdk.platform_api import list_supported_platforms


DEFAULT_SETTINGS_TEMPLATE = """# Kindling settings generated by `kindling config init`
name: {name}
version: "0.1.0"
description: "Kindling data app"

kindling:
  telemetry:
    logging:
      level: INFO
      print: true
    tracing:
      print: false

  bootstrap:
    load_lake: true
    load_local: false

  spark_configs: {{}}
  required_packages: []
  extensions: []

  # Optional secret provider configuration.
  # Use either linked_service OR key_vault_url depending on platform setup.
  secrets:
    secret_scope: "kindling-system-tests"
    # linked_service: "my-keyvault-linked-service"
    # key_vault_url: "https://my-vault.vault.azure.net/"
"""


def _render_settings_template(name: str) -> str:
    safe_name = (name or "").strip() or "my-kindling-app"
    return DEFAULT_SETTINGS_TEMPLATE.format(name=safe_name)


def _load_yaml_config(config_path: Path) -> Dict[str, Any]:
    try:
        data = yaml.safe_load(config_path.read_text(encoding="utf-8")) or {}
    except Exception as exc:
        raise click.ClickException(f"Failed to parse config file `{config_path}`: {exc}") from exc

    if not isinstance(data, dict):
        raise click.ClickException(f"Config file `{config_path}` must contain a YAML object at root.")
    return data


def _print_check_results(checks: List[Tuple[str, bool, str]]) -> bool:
    all_passed = True
    for name, passed, detail in checks:
        status = "PASS" if passed else "FAIL"
        click.echo(f"[{status}] {name}: {detail}")
        if not passed:
            all_passed = False
    return all_passed


def _detect_platform_from_environment() -> Optional[str]:
    if os.getenv("FABRIC_WORKSPACE_ID"):
        return "fabric"
    if os.getenv("SYNAPSE_WORKSPACE_NAME"):
        return "synapse"
    if os.getenv("DATABRICKS_HOST"):
        return "databricks"
    return None


@click.group(context_settings={"help_option_names": ["-h", "--help"]})
def cli() -> None:
    """Kindling CLI."""


@cli.group("config")
def config_group() -> None:
    """Manage Kindling configuration files."""


@config_group.command("init")
@click.option(
    "--output",
    "output_path",
    default="settings.yaml",
    show_default=True,
    type=click.Path(path_type=Path, dir_okay=False, writable=True),
)
@click.option("--name", default="my-kindling-app", show_default=True, help="App name in config.")
@click.option("--force", is_flag=True, help="Overwrite output file if it already exists.")
def config_init(output_path: Path, name: str, force: bool) -> None:
    """Generate an initial `settings.yaml` file."""
    destination = output_path.expanduser()
    if destination.exists() and not force:
        raise click.ClickException(
            f"Refusing to overwrite existing file `{destination}`. Use --force to overwrite."
        )

    destination.parent.mkdir(parents=True, exist_ok=True)
    destination.write_text(_render_settings_template(name), encoding="utf-8")
    click.echo(f"Wrote `{destination}`")


@cli.group("env")
def env_group() -> None:
    """Validate local environment prerequisites."""


@env_group.command("check")
@click.option(
    "--config",
    "config_path",
    default="settings.yaml",
    show_default=True,
    type=click.Path(path_type=Path, dir_okay=False, exists=False),
)
def env_check(config_path: Path) -> None:
    """Check if local environment is ready for Kindling."""
    resolved_config_path = config_path.expanduser()

    checks: List[Tuple[str, bool, str]] = []
    checks.append(
        (
            "python_version",
            sys.version_info >= (3, 10),
            f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro} (>=3.10)",
        )
    )

    exists = resolved_config_path.exists()
    checks.append(("config_file_exists", exists, str(resolved_config_path)))

    config_data: Dict[str, Any] = {}
    if exists:
        config_data = _load_yaml_config(resolved_config_path)

    kindling_section = config_data.get("kindling")
    has_kindling_section = isinstance(kindling_section, dict)
    checks.append(("kindling_section_present", has_kindling_section, "root.kindling is a mapping"))

    if _print_check_results(checks):
        click.echo("Environment check passed.")
        return

    raise click.ClickException("Environment check failed.")


@cli.group("workspace")
def workspace_group() -> None:
    """Validate and initialize workspace assets."""


@workspace_group.command("check")
@click.option("--platform", type=click.Choice(list_supported_platforms()), default=None)
@click.option(
    "--config",
    "config_path",
    default="settings.yaml",
    show_default=True,
    type=click.Path(path_type=Path, dir_okay=False, exists=False),
)
def workspace_check(platform: Optional[str], config_path: Path) -> None:
    """Check whether workspace configuration is ready for the selected platform."""
    resolved_config_path = config_path.expanduser()

    if not resolved_config_path.exists():
        raise click.ClickException(
            f"Config file `{resolved_config_path}` was not found. Run `kindling config init` first."
        )
    _load_yaml_config(resolved_config_path)

    resolved_platform = platform or _detect_platform_from_environment()
    if not resolved_platform:
        raise click.ClickException(
            "Unable to determine platform. Set --platform or one of "
            "FABRIC_WORKSPACE_ID, SYNAPSE_WORKSPACE_NAME, DATABRICKS_HOST."
        )

    required_vars = {
        "fabric": ["FABRIC_WORKSPACE_ID", "FABRIC_LAKEHOUSE_ID"],
        "synapse": ["SYNAPSE_WORKSPACE_NAME"],
        "databricks": ["DATABRICKS_HOST"],
    }[resolved_platform]

    checks = [
        (f"env:{var}", bool(os.getenv(var)), "set" if os.getenv(var) else "missing")
        for var in required_vars
    ]
    checks.insert(0, ("platform", True, resolved_platform))

    if _print_check_results(checks):
        click.echo("Workspace check passed.")
        return

    raise click.ClickException("Workspace check failed.")


@workspace_group.command("init")
@click.option(
    "--output-dir",
    default=".kindling/workspace",
    show_default=True,
    type=click.Path(path_type=Path, file_okay=False),
)
@click.option("--platform", type=click.Choice(list_supported_platforms()), default=None)
@click.option("--force", is_flag=True, help="Overwrite existing files.")
def workspace_init(output_dir: Path, platform: Optional[str], force: bool) -> None:
    """Create starter bootstrap and app notebook files for workspace setup."""
    resolved_platform = platform or _detect_platform_from_environment() or "fabric"
    output_dir = output_dir.expanduser()
    output_dir.mkdir(parents=True, exist_ok=True)

    bootstrap_path = output_dir / "bootstrap_notebook.py"
    starter_path = output_dir / "starter_notebook.py"

    if (bootstrap_path.exists() or starter_path.exists()) and not force:
        raise click.ClickException(
            f"Target files already exist in `{output_dir}`. Use --force to overwrite."
        )

    bootstrap_body = (
        "# Bootstrap Notebook Template\n"
        f"# Platform: {resolved_platform}\n\n"
        "BOOTSTRAP_CONFIG = {\n"
        "    # 'artifacts_storage_path': 'abfss://artifacts@<storage>.dfs.core.windows.net',\n"
        "    # 'environment': 'development',\n"
        "}\n\n"
        "# Execute your runtime bootstrap script here.\n"
    )
    starter_body = (
        "# Starter Notebook Template\n"
        f"# Platform: {resolved_platform}\n\n"
        "print('Kindling starter notebook ready')\n"
    )

    bootstrap_path.write_text(bootstrap_body, encoding="utf-8")
    starter_path.write_text(starter_body, encoding="utf-8")

    click.echo(f"Created `{bootstrap_path}`")
    click.echo(f"Created `{starter_path}`")


def main() -> None:
    """Console script entrypoint."""
    cli()


if __name__ == "__main__":
    main()
